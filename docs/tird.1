.\" Automatically generated by Pandoc 2.9.2.1
.\"
.TH "tird" "1" "" "" "General Commands Manual"
.hy
.SH NAME
.PP
tird - encrypt files and hide encrypted data
.SH SYNOPSIS
.PP
\f[B]tird\f[R] [\f[B]--debug\f[R]]
.SH DESCRIPTION
.PP
\f[B]tird\f[R] /t\[u026A]rd/ \f[I](an acronym for \[lq]this is random
data\[rq])\f[R] is a file encryption tool focused on minimizing metadata
and hiding encrypted data.
.PP
With \f[B]tird\f[R], you can:
.IP "1." 3
Create files filled with random data to use as containers or keyfiles.
.IP "2." 3
Overwrite the contents of devices and regular files with random data.
This can be used to prepare containers and to destroy residual data.
.IP "3." 3
Encrypt file contents and comments.
The encrypted file format (called cryptoblob) is a padded uniform random
blob (PURB): it looks like random data and has a randomized size.
This reduces metadata leakage from file format and length, and also
allows cryptoblobs to be hidden among random data.
You can use keyfiles and passphrases at your choice.
.IP "4." 3
Create steganographic (hidden, undetectable) user-driven file systems
inside container files and devices.
Unlike VeraCrypt and Shufflecake containers, \f[B]tird\f[R] containers
do not contain headers at all; the user specifies the location of the
data in the container and is responsible for ensuring that this location
is separated from the container.
.IP "5." 3
Prevent or resist coercive attacks (keywords: key disclosure law,
rubber-hose cryptanalysis, xkcd 538).
\f[B]tird\f[R] provides some forms of plausible deniability out of the
box, even if you encrypt files without hiding them in containers.
.SH COMMAND-LINE OPTIONS
.SS --debug
.PP
enable debug mode
.SH USAGE
.PP
You don\[cq]t need to memorize command-line options to use
\f[B]tird\f[R].
This tool features a prompt-based CLI: simply start it, select a menu
option, and answer the questions that will follow.
.IP
.nf
\f[C]
$ tird

                       MENU
    \[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]
    0. Exit              1. Info & Warnings
    2. Encrypt           3. Decrypt
    4. Embed             5. Extract
    6. Encrypt & Embed   7. Extract & Decrypt
    8. Create w/ Random  9. Overwrite w/ Random
    \[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]
A0. Select an option [0-9]:
\f[R]
.fi
.PP
A detailed description of these options with examples can be found here:
<https://github.com/hakavlad/tird/blob/main/docs/INPUT_OPTIONS.md>.
.SH INPUT OPTIONS
.PP
There are 5 groups of input options: A (Action), C (Custom), D (Data), K
(Keys), P (Proceed).
They are numbered for ease of description.
.IP
.nf
\f[C]
+\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]+\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]+
| A0. Select an option     | A. Select an action    |
+\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]+\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]+
| C0. Use custom settings? |                        |
| C1. Time cost            | C. Set custom settings |
| C2. Max padding size     |                        |
| C3. Set fake MAC tag?    |                        |
+\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]+\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]+
| D1. Input file path      |                        |
| D2. Comments             | D. Enter data,         |
| D3. Output file path     |    data location,      |
| D4. Output file size     |    data size           |
| D5. Start position       |                        |
| D6. End position         |                        |
+\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]+\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]+
| K1. Keyfile path         | K. Specify input       |
| K2. Passphrase           |    keying material     |
+\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]+\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]+
| P0. Proceed?             | P. Confirm to continue |
+\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]+\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]+
\f[R]
.fi
.SH GOALS
.IP \[bu] 2
\f[B]File Protection:\f[R] Ensuring protection for individual files,
including:
.RS 2
.IP \[bu] 2
Symmetric encryption and authentication.
.IP \[bu] 2
Minimizing metadata leakage.
.IP \[bu] 2
Preventing access to data in cases of user coercion.
.IP \[bu] 2
Plausible deniability of payload existence.
.IP \[bu] 2
Hiding encrypted data.
.RE
.IP \[bu] 2
\f[B]Stable Format:\f[R] Ensuring a stable encryption format with no
cryptographic agility for long-term data storage.
.IP \[bu] 2
\f[B]Simplicity:\f[R] Ensuring simplicity and avoiding feature creep:
refusal to implement features that are not directly related to primary
security goals.
.SH PAYLOAD
.PP
The payload that will be encrypted during cryptoblob creation consists
of:
.IP \[bu] 2
\f[B]Contents of one file:\f[R] This may be a regular file or a block
device (an entire disk or partition).
Maximum size: 16 exbibytes minus 864 bytes.
.IP \[bu] 2
\f[B]Comments (optional):\f[R] An arbitrary string of up to 512 bytes.
Decrypted comments will be displayed during decryption.
.PP
Specifying the payload in the UI looks as follows:
.IP
.nf
\f[C]
D1. File to encrypt: list.txt
    I: path: \[aq]list.txt\[aq]; size: 6,493 B (6.3 KiB)
D2. Comments (optional, up to 512 B): Epstein client list, txt
    I: comments will be shown as [\[aq]Epstein client list, txt\[aq]]
\f[R]
.fi
.SH INPUT KEYING MATERIAL
.PP
\f[B]tird\f[R] provides the option to use passphrases and the contents
of keyfiles to derive one-time keys.
.IP \[bu] 2
\f[B]Keyfiles:\f[R] Specify none, one, or multiple keyfile paths.
A keyfile path may be:
.RS 2
.IP \[bu] 2
A regular file.
The contents of the keyfile will be hashed, and its digest will be used
for further key stretching and key derivation.
.IP \[bu] 2
A block device.
Handled the same as a regular keyfile: contents will be hashed.
.IP \[bu] 2
A directory.
All files within the directory will be hashed and used as keyfiles.
.RE
.IP \[bu] 2
\f[B]Passphrases:\f[R] Specify none, one, or multiple passphrases of up
to 2048 bytes.
.PP
The order of input does not matter.
.PP
Specifying IKM in the UI looks as follows:
.IP
.nf
\f[C]
K1. Keyfile path (optional): foo
    I: path: \[aq]foo\[aq]; size: 1 B
    I: reading and hashing contents of \[aq]foo\[aq]
    I: keyfile accepted
K1. Keyfile path (optional):
K2. Passphrase (optional):
K2. Confirm passphrase:
    I: passphrase accepted
\f[R]
.fi
.SH HIDDEN FILE SYSTEM AND CONTAINER FORMAT
.PP
You can encrypt files and embed cryptoblobs into containers starting at
arbitrary positions.
After writing the cryptoblob, you will need to remember its location in
the container (the starting and ending positions), which will be used
later to extract the cryptoblobs.
In this way, you can create a \f[B]hidden, headerless, user-driven\f[R]
file system inside a container:
.IP \[bu] 2
It is \f[B]hidden\f[R] because it is impossible to distinguish between
random container data and cryptoblob data, as well as to determine the
location of written cryptoblobs without knowing the positions and keys.
.IP \[bu] 2
It is \f[B]headerless\f[R] because containers do not contain any
headers; all data about cryptoblob locations must be stored separately
by the user.
.IP \[bu] 2
The starting position of the cryptoblob in the container is
\f[B]user-defined\f[R], and the \f[B]user must\f[R] store both the
starting and ending positions separately from the container.
This is why it is called a \f[B]user-driven file system\f[R].
.PP
Any file, disk, or partition larger than the minimum cryptoblob size
(863 B) can be a valid container.
Cryptoblobs can be embedded into any area.
.PP
\f[B]Examples of valid containers include:\f[R]
.IP "1." 3
Specially generated files with random data.
.IP "2." 3
\f[B]tird\f[R] cryptoblobs, as they contain pockets \[em]
unauthenticated padding of random data \[em] by default, which can be
used to embed smaller cryptoblobs.
.IP "3." 3
Disk areas containing random data.
For example, you can overwrite a disk with random data, format it in
FAT32 or exFAT, and use a large portion of the disk, leaving a few dozen
MB from the beginning.
The disk will appear empty unless you add some files to it.
.IP "4." 3
LUKS encrypted volumes.
.IP "5." 3
VeraCrypt containers, even those that already contain hidden volumes.
.PP
\f[B]Example of container structure:\f[R]
.IP
.nf
\f[C]
+\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]+\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]+ <\[em] Position 0 of the container
|         |             |
|         | Random data |
|         |             |
|         +\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]+ <\[em] Cryptoblob1 start position
| Header- |             |
| less    | Cryptoblob1 |
|         |             |
| Layer   +\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]+ <\[em] Cryptoblob1 end position
|         | Random data |
| Cake    +\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]+ <\[em] Cryptoblob2 start position
|         |             |
|         | Cryptoblob2 |
|         |             |
|         +\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]+ <\[em] Cryptoblob2 end position
|         | Random data |
+\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]+\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]\[em]+
\f[R]
.fi
.SH TIME-LOCK ENCRYPTION
.PP
Time-lock encryption (TLE) can be used to prevent an adversary from
quickly accessing plaintexts in the event of an IKM compromise (in case
of user coercion, for example).
In our implementation, it is actually a PoW-based time-lock key
derivation.
The \[lq]Time cost\[rq] input option specifies the number of Argon2
passes.
If you specify a sufficiently high number of passes, it will take a
significant amount of time to perform them.
However, an attacker will require the same amount of time when using
similar hardware.
The execution of Argon2 cannot be accelerated through parallelization,
so it is expected that the time spent by an attacker will be
approximately the same as that spent by the defender.
.PP
This TLE implementation works offline, unlike \f[B]tlock\f[R].
.PP
Use custom options and set the desired \[lq]Time cost\[rq] value:
.IP
.nf
\f[C]
C0. Use custom settings? (Y/N, default=N): y
    I: use custom settings: True
    W: decryption will require the same [C1] and [C2] values!
C1. Time cost (default=4): 1000000
    I: time cost: 1,000,000
\f[R]
.fi
.PP
\f[B]Plausible TLE:\f[R] The adversary does not know the actual value of
the time cost, so you can plausibly misrepresent the number of passes.
The adversary cannot refute your claim until they attempt to decrypt the
cryptoblob using the specified time cost value.
.SH DEBUG MODE
.PP
\f[B]WARNING:\f[R] Debug mode is not intended for use in production!
.PP
Start \f[B]tird\f[R] with the option \f[B]--debug\f[R] to look under the
hood while the program is running.
.PP
Enabling debug mode additionally shows:
.IP \[bu] 2
File operations:
.RS 2
.IP \[bu] 2
Opening and closing of file descriptors.
.IP \[bu] 2
Real paths to opened files.
.IP \[bu] 2
Movement of file pointers.
.RE
.IP \[bu] 2
Byte strings related to cryptographic operations: salts, passphrases,
digests, keys, nonces, and tags.
.IP \[bu] 2
Some other information, including various sizes.
.SH TRADEOFFS AND LIMITATIONS
.IP \[bu] 2
\f[B]tird\f[R] does not support:
.RS 2
.IP \[bu] 2
Public-key cryptography.
.IP \[bu] 2
File compression.
.IP \[bu] 2
ASCII armored output.
.IP \[bu] 2
Reed\[en]Solomon error correction.
.IP \[bu] 2
Splitting the output into chunks.
.IP \[bu] 2
The use of standard streams for processing files.
.IP \[bu] 2
Low-level block device reading and writing on MS Windows.
As a result, these devices cannot be used as keyfiles, cannot be
overwritten, and cannot be encrypted or embedded.
.RE
.IP \[bu] 2
\f[B]tird\f[R] does not provide:
.RS 2
.IP \[bu] 2
A graphical user interface.
.IP \[bu] 2
A password generator.
.RE
.IP \[bu] 2
\f[B]tird\f[R] cannot handle (encrypt/embed) more than one file in one
pass.
Encryption of directories and multiple files is not supported.
.IP \[bu] 2
\f[B]tird\f[R] does not fake file access, modification, and creation
timestamps (atime, mtime, ctime).
.IP \[bu] 2
\f[B]tird\f[R]\[cq]s encryption speed is not very high (up to 420 MiB/s
in my tests).
.SH WARNINGS
.IP \[bu] 2
The author does not have a background in cryptography.
.IP \[bu] 2
The code has no automated test coverage.
.IP \[bu] 2
\f[B]tird\f[R] has not been independently security audited by humans.
.IP \[bu] 2
\f[B]tird\f[R] is ineffective in a compromised environment; executing it
in such cases may cause disastrous data leaks.
.IP \[bu] 2
\f[B]tird\f[R] is unlikely to be effective when used with short and
predictable keys.
.IP \[bu] 2
\f[B]tird\f[R] does not erase its sensitive data from memory after use.
.IP \[bu] 2
Sensitive data may leak into swap space.
.IP \[bu] 2
\f[B]tird\f[R] always releases unverified plaintext, violating the
Cryptographic Doom Principle; decrypted output is untrusted until the
MAC tag is verified.
.IP \[bu] 2
Padding contents are never authenticated; authentication only applies to
the ciphertext, salts, and certain sizes.
.IP \[bu] 2
Padding sizes depend on secret values.
.IP \[bu] 2
\f[B]tird\f[R] does not sort digests of keyfiles and passphrases in
constant-time.
.IP \[bu] 2
Overwriting file contents does not guarantee secure destruction of data
on the media.
.IP \[bu] 2
You cannot prove to an adversary that your random data does not contain
encrypted information.
.IP \[bu] 2
\f[B]tird\f[R] protects data, not the user; it cannot prevent torture if
you are under suspicion.
.IP \[bu] 2
Key derivation consumes 1 GiB RAM, which may lead to performance issues
or crashes on low-memory systems.
.IP \[bu] 2
Development is not complete, and there may be backward compatibility
issues.
.SH REQUIREMENTS
.IP \[bu] 2
Python >= 3.9.2
.IP \[bu] 2
cryptography >= 2.1
.IP \[bu] 2
PyNaCl >= 1.2.0
.IP \[bu] 2
colorama >= 0.4.6 (Windows-specific)
.SH TUTORAL
.PP
Step-by-step guides and examples can be found here:
<https://github.com/hakavlad/tird/blob/main/docs/tutorial/README.md>.
.SH SPECIFICATION
.PP
See <https://github.com/hakavlad/tird/blob/main/docs/SPECIFICATION.md>.
.SH REPORTING BUGS
.PP
Please report bugs at <https://github.com/hakavlad/tird/issues>.
.SH FEEDBACK
.PP
Please feel free to ask questions, leave feedback, or provide critiques
in the Discussions <https://github.com/hakavlad/tird/discussions>
section.
.SH AUTHOR
.PP
Alexey Avramov <hakavlad@gmail.com>
.SH LICENSE
.PP
This project is licensed under the terms of the BSD Zero Clause License
(0BSD):
.IP
.nf
\f[C]
Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED \[dq]AS IS\[dq] AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
\f[R]
.fi
.SH HOMEPAGE
.PP
Homepage is <https://github.com/hakavlad/tird>.
